<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="IntentCoarsegrainedsynchronization">Intent : Coarse grained synchronization</h1><h2 id="Overview">Overview</h2><p>For the time being, if you want to synchronize content with Intent, you have to describe the whole content inside Model fragments. This allows you to have a fine-grained synchronization, where you can associate each model element/feature to a dedicated section to have precise synchronization informations.</p><p>This can be a burden, especially when you describe a whole file/model or an important piece of code inside a paragraph.</p><p>This document specifies how Intent can handle coarse grained synchronization. Note that Intent must allow to use coarse-grained synchronization with models directly stored in the Intent repository.</p><h2 id="Enduserscenarios">End-user scenarios</h2><p>The following scenarios must be allowed by Intent once this feature is implemented:</p><h3 id="a1SpecifyanewrequirementsusingIntentJnariolikesyntax">1) Specify a new requirements using Intent &amp; Jnario-like syntax</h3><p><strong>As a</strong> specifier<br/><strong>I want to</strong> specify a feature &#8249;Create a class&#8250; (with Jnario-like syntax when possible)<br/><strong>So that</strong></p><ul><li>developpers can code feature</li><li>tests can be generated an written</li><li>[user guide can be produced] (requirement considered as out of scope of the 2 first iterations)</li></ul><p><strong>Given</strong> a requirement<br/><strong>When</strong></p><ul><li>I create a Section named 'Create a class'</li><li>Optional :  I add explanations in the section</li><li>I create a Model fragment pointing to a new Jnario file </li></ul><p>@M<br/> @ref "intent:/myIntentProject/createaclass.jnario"<br/>M@</p><p><strong>Then</strong></p><ul><li>When ctrl-clicking on the @ref instruction, the default editor associated to this extension should be opened</li><li>When editing the jnario file, no synchronization issue should be raised (of course changes should be persisted)</li></ul><h3 id="a2ImplementarequirementspecifiedinIntentthroughVSMedition">2) Implement a requirement specified in Intent (through VSM edition)</h3><p><strong>As a</strong> developper<br/><strong>I want to</strong> implement the feature specified in 1)<br/><strong>So that</strong> my modeler fulfills this new requirement<br/><strong>Given</strong> the intent section as specified in 1)<br/><strong>When</strong></p><ul><li>I create a new tool in my VSM to implement the feature</li><li>I drag the created tool in the Intent Section</li></ul><p><strong>Then</strong></p><ul><li>If a <code>ResourceDeclaration</code> matching the given element&#8217;s URI has already been defined, then the standard intent behavior will be applied (creation of all model fragments instructions allowing to describe the dropped element)</li><li>If not, a pop-up asking me whether I want to <strong>create</strong> or <strong>reference</strong> the dragged element will be displayed:<ul><li>I should be able to check an &#8249;Always apply this choice&#8250; checkbox, avoiding the pop-up to appear again (preference should be editable in Intent UI preferences)</li><li>if I select &#8249;create&#8250;, then the standard intent behavior will be applied</li><li>if I select &#8249;reference&#8250;:<ul><li> then the following instruction will be created : @ref "platform:/resource/myVSMProject/description/myVSM.odesign#//FRAGMENT_OF_THE_DRAGGED_ELEMENT"</li><li>When ctrl-clicking on the @ref instruction, the default editor associated to this extension should be opened <strong>on the working copy version of this file</strong></li><li>When modifying the VSM, Intent should detect synchronization issues in real-time, that can be displayed as usual. To fix a synchronization issue, I apply the &#171;Update ModelingUnit&#187; quick-fix (maybe in that case the quick-fix should be entitled <em>'mark as merged'</em> ?).</li></ul></li></ul></li></ul><h3 id="a3Writetestsfortheimplementedfeature">3) Write tests for the implemented feature</h3><p>We identified 2 ways for writing the test: </p><ul><li><strong>3.1</strong> by generating a junit test skeleton and edit it</li><li><strong>3.2</strong> by defining a scenario model that then will be interpreted (Doc Driven Testing)</li></ul><p><strong>As a</strong> tester<br/><strong>I want to</strong> test the feature specified in 1) and implemented in 2)</p><h4 id="a3.1Testimplementation">3.1) Test implementation</h4><p><strong>When</strong></p><ul><li>I generate my Test implementation</li><li>I edit my generated test to test the feature</li><li>I drag the created java method  (<code>testCreateAClass()</code>) in the Intent Section (notice that this step may be automated during test generation)</li></ul><p><strong>Then</strong></p><ul><li>Same pop-up behavior as specified above</li><li>If I chose &#8249;reference&#8250;:<ul><li>then the following instruction will be created : @ref &#171;my.java.project/src/my/java/project/CreateAType.java#//@methods[name='testCreateAClass']&#187; (syntax is provisional)</li><li>When ctrl-clicking on the @ref instruction, the java editor should be opened and focused on the method</li><li>When modifying this method, Intent should detect synchronization issues in real-time, that can be displayed as usual. To fix a synchronization issue, I apply the &#171;Update ModelingUnit&#187; quick-fix (maybe in that case the quick-fix should be entitled <em>'mark as merged'</em> ?).</li></ul></li></ul><h4 id="a3.2Scenariointerpretation">3.2) Scenario interpretation</h4><p><strong>When</strong></p><ul><li>I create a link to a new scenario model @ref "intent:/myIntentProject/createaclass.scenario"</li><li>I generate a junit test testing this scenario</li></ul><p>Then</p><ul><li>Same behavior as with the jnario file in 1) and java file in 3.1.</li></ul><h2 id="Technicalspecification">Technical specification</h2><p>Through this specification, we will take the example of the following java test file : </p><pre><code>package my.java.project;

/**
  Javadoc1.
*/
public class CreateAType {

    /**
       Javadoc 2.    
    */
	@Test
	public void createAClass() throws Exception {
		// some piece of code
	}
	
	// MIDDLE COMMENT
	
	/**
	  Javadoc 3.
	*/
	@Test
	public void createAnEnumeration() throws Exception {
		// some piece of code
	}
}

</code></pre><h3 id="Syntaxparsing">Syntax &amp; parsing</h3><p>We will name this concept <strong>External Content Reference</strong>, as the content to synchronize is not described directly inside the document, but through a reference to an external file.</p><h4 id="ExternalReferenceSyntax">ExternalReference Syntax </h4><p>We propose the following syntax for referencing the content of an external file:</p><pre><code>@ref "&lt;FILE_LOCATION&gt;"
@ref "&lt;FILE_LOCATION&gt;#&lt;FRAGMENT&gt;" 

</code></pre><p>For example : </p><pre><code>@ref "my.java.project/src/my/java/project/CreateAType.java"
</code></pre><p>&gt; Describes the content of the whole class  (including the class javadoc &amp; annotations)</p><pre><code>@ref "my.java.project/src/my/java/project/CreateAType.java#//methods[name='myMethod']"
</code></pre><p>&gt; Describes the content of the &#8249;myMethod&#8250; method (including this method javadoc &amp; annotations)</p><pre><code>@ref "platform:/resource/myVSMProject/description/myVSM.odesign#&lt;URI_FRAGMENT&gt;"
</code></pre><p>&gt; Describes the model element of the myVSM.odesign resource having the given fragment </p><h4 id="ExternalContentReferenceparsing">ExternalContentReference parsing</h4><p>The ModelingUnit parser will be modified to accept the described syntax.<br/>It will represent an external content as an instance of the following EClass :</p><pre><code>EClass ExternalContentReference extends ResourceDeclaration {
	// The inherited field "URI" will store the reference URI
}

</code></pre><p>The External Content Reference extends ResourceDeclaration so that the compiler can create a resource to store the external content reference, and mainting traceability informations (see <a href="#ExternalContentReferenceCompilation">following section</a> ).</p><pre><code>ExternalContentReference {
    eStructuralFeatures += new EAttributes markedAsMerged {
         eType = EBoolean;
    };
}
</code></pre><p>This attribute will allow to determine whether the external content should be overridden with the last working copy value (if true) or not (see <a href="#ExternalContentReferenceCompilation">following section</a> .</p><pre><code>ExternalContentReference {
     eStructuralFeatures += new EReference externalContent {
        eType = EObject;
     };
}
</code></pre><p>This reference stores the last sync value for the external content (set by the compiler).</p><h3 id="ExternalContentReferenceCompilation">ExternalContentReference Compilation</h3><h4 id="Compilation">Compilation</h4><p>We will add a new case to the <code>ModelingUnitGenerator</code> when having to compile and <code>ExternalContentReference</code>, that will call a new <code>ExternalContentReferenceGenerator</code>.</p><ul><li>If the ExternalContentReference&#8217;s externalContent reference is null (i.e. not initialized) or if it is marked as merge (i.e. we should get the latest working copy value), then we have to get the working copy value of this external Content. To do so, we get the external content EObject using the compiler&#8217;s resource set (extensible through a <a href="#Extensibility">Resource Factory</a> ).</li><li>Otherwise, we use the value of this reference</li></ul><p>We will register this external reference contribution in the compiler&#8217;s information holder, so that : </p><ul><li>the external content can be saved as any other Intent resource (the only difference is that instead of defining it inside model fragments, the generated element has been copied from working copy)</li><li>traceability informations can be registered (and used e.g. for hyperlink detections)</li></ul><h4 id="Extensibility">Extensibility</h4><p>We saw that the compiler uses the ResourceSet to get the External Content. So for instance : </p><pre><code>@ref "platform:/resource/myProject/myEcore.ecore"
</code></pre><p>will be resolved with the default resource factories.</p><p>If we want to provide a way to get the java files external content (in our example, as models with a method granularity), we will have to create a new Resource factory allowing to represent a java file as a model and associate it to the <code>.java</code> file extension.</p><h3 id="ExternalContentReferenceSynchronization">ExternalContentReference Synchronization</h3><h4 id="Synchronization">Synchronization</h4><p>The Intent synchronizer will still compare the resource generated by Intent (that was calculated using the ExternalContentReference&#8217;s externalContent) and the working copy value (recalculated using the provided resource factories). It will raise synchronization issues on the ExternalContentReference if differences are found.</p><p>The only modifications on the IntentSynchronizer will be relative to the synchronization granularity: although EMF Compare 1 made compare 2 whole resources, we can now compare EObjects (and we have that need for partial external content references).</p><p>To fix an issue related to an ExternalContentReference, we just have to mark it as merged (set the attribute to true): then the compiler will get the latest working copy version and the synchronization issue will be fixed.</p><h5 id="Dealingwithreferencesoutofscope">Dealing with references out of scope</h5><p>If you are synchronizing a model element referencing other model elements, the compiled copy element will reference the working copy elements.</p><p>For instance, with the following ecore model : </p><pre><code>Package p1 {
 EClass c1 extends c2
 EClass c2
}

</code></pre><p>if you are only referencing c1, </p><pre><code>@ref "platform:/resource/my.java.project/test.ecore#//c1"
</code></pre><p>then the copy c1 will extends the working copy version of c2.</p><h3 id="Draganddropsupport">Drag and drop support</h3><p>To drop for instance a new java file, user will have to:</p><ul><li>open it with the sample reflective editor</li><li>drop the content inside the Intent document.</li></ul><p>If a ResourceDeclaration matching this java file&#8217;s URI is found, we will drop it as a ModelFragment (existing dropping mechanism). If not, we will display a pop-up allowing the end-user to choose between fine and coarse-grained synchronization.</p><p>A new UI preference editable through the Intent UI Preferences will be created, allowing to specify how drag-and-drop is handled:</p><ul><li>reference an existing element</li><li>create a copy in a model fragment</li><li>always ask user</li></ul><p>This pop-up should display a &#8249;Always apply this choice&#8250; checkbox, allowing to set this preference to the expected value.</p><h3 id="Hyperlinksupport">Hyperlink support</h3><p>To open some kind of editors (e.g. a Java editor), we will have to create a FileEditorInput (instead of a URIEditorInput which is the default). As the IntentEditor plugin does not depends on org.eclipse.core.resource, we will not be able to do so. Hence we will add the following method to the <code>IExternalContentGraphicalRendered</code> : </p><ul><li><code>boolean openEditor(ExternalContentReference externalContentReference)</code>. If false is returned, then the default URIEditorInput-based opening mechanism will be used.</li></ul><h3 id="Javabridgeiteration1">Java bridge (iteration 1)</h3><p>To prove the extensibility of this approach, we will provide an extension allowing to make external references to java files.</p><p>This task includes all possible extension at this point (resource factory &amp; hyperlink detectors).</p><h3 id="Tests">Tests</h3><p>2 kind of tests will be written: </p><ul><li>Test the external references with models</li><li>Test the external references using the Java files bridge</li></ul><h2 id="Iteration2displayandexport">Iteration 2: display and export</h2><h3 id="DisplayingfilecontentinModelFragments">Displaying file content in Model Fragments</h3><p>We want to display the content associated to the external content reference inside the Modeling Fragment (for instance the java file).</p><p>To do so, we will provide an extension point in the IntentEditor plugin, allowing to provide an <code>IExternalContentGraphicalRenderer</code> defined as below:</p><ul><li><code>boolean isRenderedFrom(EObject externalContent)</code> :  This methods indicates whether this IExternalContentGraphicalRenderer can be applied on the given externalContent, according for example to  the externalContent&#8217;s EClass.</li><li><code>void render(EObject externalContent, IntentEditor editor)</code>.This could draw the text of a Java file, or the image of diagram.</li></ul><h3 id="DocumentationExport">Documentation Export</h3><p>When exporting the documentation, we will add a boolean allowing to specify whether external content should be rendered or not.</p><p>Each contribution will be able to override the export of the ExternalContent (with guards to avoid overriding the behavior when not relevant), and for instance : </p><ul><li>override the header template to add a new javascript library to handle java syntaxic coloring</li><li>override the ExternalContent export to print the java file</li><li>override the ExternalContent export to copy and reference an image (e.g. for diagrams)</li></ul><h3 id="Performances">Performances </h3><p>After a first implementation, we will analyse the performances of this mechanism, and add, if required:</p><ul><li>Caching mechanisms (for example using hashcodes/timestamps to determine if a java file has changed and needs to be compared, cache parsed java tags...)</li><li>Provide a fine grained synchronization, to only compare the files that have changed</li></ul></body></html>